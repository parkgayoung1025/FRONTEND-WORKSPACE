<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열</title>
    <style>
        .area{
            width: 300px;
            border: 1px solid pink;
        }
        .small{
            height: 100px;
        }
        .big{
            height: 200px;
        }
    </style>
</head>
<body>
    <h1>배열</h1>

    <p>
        자바스크립트에서는 변수 선언 시 별도의 자료형 지정이 없기 때문에 <br>
        어떤 자료형의 값 들이던 다 하나의 배열 공간에 담을 수 있음(자바의 컬렉션과 유사)
    </p>

    <button onclick="arrayTest1();">확인</button>

    <div id="area1" class="area small"></div>

    <script>
        function arrayTest1() {
            let arr = ["홍길동", '서울', 20, true, [1, 2, 3]];
            arr.newKey = "배열에다가 새로운 키 값 추가";

            console.log(arr); // ["홍길동", '서울', 20, true, [1, 2, 3]]
            console.log(arr[2]); // 20
            console.log(arr[4]); // [1, 2, 3]
            console.log(arr[4][0]); // 1

            let area1 = document.getElementById("area1");

            // for(let i=0; i<arr.length; i++) {
            //     area1.innerHTML += arr[i] + "<br>";
            // } 기본 반복문

            // 향상된 반복문
            // 배열의 0번 인덱스에서부터 마지막 인덱스까지 단순하게 순차적으로 접근할 목적이면
            // for of, for in 문 활용 가능

            for(let 변수명 of/in 반복을 시킬 배열/객체)
            for(let item of arr){
                area1.innerHTML += item + "<br>";
            } // 배열의 0~n번째 인덱스에 있는 값들만 반복함

            // for(let i in arr){ // 객체의 key 값에 접근함
            //     area1.innerHTML += arr[i] + "<br>";
            // } // 배열의 모든 key 값을 순차적으로 반복함
            
            // for in 보다는 for of 쓰는 것을 권장
            // for in은 객체를 반복할 때 쓰는 것을 권장
        }
    </script>

    <hr>

    <h3>* 배열의 선언</h3>

    <p>
        배열 선언 시 배열의 크기를 지정한 체로 선언하거나 크기를 지정하지 않아도 됨(배열의 크기에 제약이 없다.)
    </p>

    <button onclick="arrayTest2();">확인하기</button>

    <script>
        function arrayTest2(){
            let arr1 = []; // 배열의 크기가 0인 빈 배열 선언
            let arr2 = new Array(); // 배열의 크기가 0인 빈 배열 선언
            let arr3 = new Array(3); // 배열의 크기가 3인 빈 배열 선언

            console.log(arr1);
            console.log(arr2);
            console.log(arr3);

            // 배열에 값 대입
            arr1[0] = '바나나';
            arr1[1] = "사과";
            arr1[10] = "키위";
            // 배열의 크기가 11로 늘어나 있음 [2]~[9]까진 빈 값으로 추가

            console.log(arr1);

            arr3[0] = "자동차";
            arr3[1] = "기차";
            arr3[2] = "도보";
            arr3[3] = "비행기"; // 배열의 크기가 4로 늘어났다.

            console.log(arr3);

            // 배열 선언과 동시에 초기화
            let arr4 = new Array("홍길동", "임꺽정");
            let arr5 = ["자바", "오라클", "스프링"];

            console.log(arr4);
            console.log(arr5);
        }
    </script>

    <hr>

    <h3>* Array 객체의 메서드</h3>

    <h4>
        1) indexOf(찾고자 하는 요소) <br>
           배열에서 해당 요소가 위치해있는 인덱스를 반환
    </h4>

    <div id="area2" class="area small"></div>

    <button onclick="indexOfTest();">확인</button>

    <script>
        function indexOfTest(){
            let area2 = document.getElementById("area2");

            let arr = ["사과", "딸기", "복숭아", "샤인머스켓", "파인애플"];
            let fruit = prompt("찾고자 하는 과일명을 입력하시오.");

            let index = arr.indexOf(fruit);
            // 배열에 존재하지 않는 요소를 입력 시 -1을 반환

            console.log(index);

            // 찾고자 하는 과일이 있을 경우 : 당신이 찾는 과일 xxx는 x번째 인덱스에 있습니다.
            // 찾고자 하는 과일이 없을 경우 : 당신이 찾는 과일 xxx는 판매하지 않습니다.

            area2.innerHTML = "당신이 찾는 과일 " + fruit + "은(는) "
            if(index == -1){
                area2.innerHTML += "판매하지 않습니다.";
            }else{
                area2.innerHTML += index + "번째 인덱스에 있습니다.";
            }

            console.log(1 == 1); // true
            console.log(1 == "1"); // true => 동등 연산자 : 자료형과 무관하게 실제 값만 일치하면 true
            console.log(1 === "1"); // false => 일치 연산자 : 값 + 자료형이 일치해야 true 값을 반환
        }
    </script>

    <hr>

    <h4>2) concat(배열, 배열, ...) : 여러 개의 배열을 결합하고자 할 때 사용</h4>

    <div id="area3" class="area big"></div>

    <button onclick="concatTest();">확인하기</button>

    <script>
        function concatTest(){
            let area3 = document.getElementById("area3");

            let arr1 = ["사과", "딸기"];
            let arr2 = ["자동차", "비행기", "지하철"];

            area3.innerHTML += "arr1 : " + arr1 + "<br>";
            area3.innerHTML += `arr2 : ${arr2} <br>`;

            area3.innerHTML += "arr1 기준으로 배열 합치기 : " + arr1.concat(arr2) + "<br>";
            area3.innerHTML += "다시 arr1 : " + arr1 + "<br>";
            // 원본 배열에 영향을 끼치지 않는 메서드
            // 두 개의 배열을 합쳐서 새로운 배열로 반환

            area3.innerHTML += "여러 개의 배열 합치기 : " + arr1.concat(arr2, [1, 2, 3], ["삼겹살", "항정살"]);
        }
    </script>

    <hr>

    <h4>3) reverse() : 배열에 담긴 값들을 역순으로 바꿔주는 메서드</h4>

    <div id="area4" class="area small"></div>

    <button onclick="reverseTest();">확인</button>

    <script>
        function reverseTest(){
            let area4 = document.getElementById("area4");

            let arr = [1, 2, 3, 4, 5];

            area4.innerHTML += "arr : " + arr + "<br>";
            area4.innerHTML += "reverse 결과 : " + arr.reverse() + "<br>";
            area4.innerHTML += "원본 arr : " + arr + "<br>";
            // 원본 배열에 영향을 끼치는 메서드 
        }
    </script>

    <h4>4) sort() : 배열 안에 담긴 값들을 오름차순으로 정렬시켜주는 메서드</h4>

    <div id="area5" class="area small"></div>

    <button onclick="sortTest();">확인</button>

    <script>
        function sortTest(){
            let area5 = document.getElementById("area5");

            let arr = ["박가영", "박다영", "박마영", "박나영", "박라영"];

            area5.innerHTML += "arr : " + arr + "<br>";
            area5.innerHTML += "sort 결과 : " + arr.sort() + "<br>";
            area5.innerHTML += "다시 arr : " + arr + "<br>";
            // 원본 배열에 영향을 끼치는 메서드

            // 내림차순으로 정렬하고 싶다면 => 오름차순으로 정렬 후 역순으로 뒤집기
            area5.innerHTML += '내림차순 정렬 : ' + arr.sort().reverse() + "<br>";

            // 특이 케이스
            let arr2 = [1, 2, 15];
            console.log(arr2.sort());
            // sort 함수 실행 시 배열의 각 요소를 "문자열"로 취급하여 정렬하기 때문에
            // 문자열 기준으로 오름차순 정렬됨

            // 배열 안에 객체가 담겨있는 경우
            // 기존 정렬 기준 대신 새로운 정렬 기준을 만들어야 한다.
            // 1) 정렬 기준을 새로 만들기
            function compare(a, b){
                if(a > b) return 1; // 첫 번째 요소가 두 번째 요소보다 큰 경우
                if(a == b) return 0; // 같은 경우
                if(a < b) return -1; // 더 작은 경우
            }

            // 2) sort 메서드 호출 시 매개 변수로 내가 만든 정렬 기준을 추가한다.
            console.log(arr2.sort(compare));

            // 2-1) 그 외 방법
            console.log(arr2.sort(function(a, b) {return a-b})); // a-b : 오름차순 / b-a : 내림차순
            // 오름차순 정렬하는 정렬 기준을 매개 변수에 직접 함수로 추가
            // 양수 반환 시 -> 크다, 음수 반환 시 -> 작다로 해석하여서 정렬함

            console.log(arr2.sort((a, b) => a-b)); // 위 코드와 동일한 코드
        }
    </script>

    <hr>

    <h4>
        5-1) push(추가할 요소) : 배열의 맨 뒤에 요소를 추가하고 배열의 크기 반환 <br>
        5-2) pop() : 배열의 맨 뒤 요소를 제거하고 제거된 요소를 반환
    </h4>

    <div id="area6" class="big area"></div>

    <button onclick="pushPopTest();">확인</button>

    <script>
        function pushPopTest(){
            let area6 = document.getElementById("area6");

            let arr = ["서초동", "방배동", "역삼동", "삼성동", "대치동"];

            area6.innerHTML += "arr : " + arr + "<br>";
            arr.push("신사동");
            area6.innerHTML += "arr에 push 후 : " + arr + "<br>";
            area6.innerHTML += "arr에 push 후 배열의 크기는 : " + arr.push("논현동") + "<br>";
            area6.innerHTML += "원본 arr : " + arr + "<br>";

            area6.innerHTML += "arr에 pop 후 : " + arr.pop() + "<br>";
            area6.innerHTML += "원본 arr : " + arr + "<br>";

            // 원본 배열에 영향을 끼치는 메서드
            arr.pop();
            arr.pop();
            arr.pop();

            area6.innerHTML += "최종 arr : " + arr + "<br>";

            arr[5] ="dd"; // 이렇게도 값을 추가할 수 있음
            console.log(arr.length);

            arr.pop();
            arr.pop();
            arr.pop();

            console.log(arr);
        }
    </script>

    <hr>

    <h4>
        6-1) unshift(추가할 요소) : 배열의 맨 앞에 요소 추가 후 배열의 크기 반환 <br>
        6-2) shift() : 배열의 맨 앞에 요소 제거하고 제거된 요소 반환
    </h4>

    <div id="area7" class="area big"></div>

    <button onclick="shiftTest();">확인</button>

    <script>
        function shiftTest(){
            let area7 = document.querySelector("#area7");

            let arr = ["야구", "볼링", "테니스", "탁구"];

            area7.innerHTML += "arr : " + arr + "<br>";
            arr.unshift("농구");
            area7.innerHTML += "arr에 unshift 함수 사용 후 : " + arr + "<br>";

            area7.innerHTML += "arr에 shift 사용 후 : " + arr.shift() + "<br>";
            area7.innerHTML += "최종 arr : " + arr + "<br>";
        }
    </script>

    <h4>
        7-1) slice(시작, 끝) : 배열 안의 요소들을 단지 추출해 주는 메서드<br>
        7-2) splice(시작, 제거할 개수, 추가 값) : 배열의 요소를 추출해서 제거 및 추가. 추가 값은 생략 가능
    </h4>

    <div id="area8" class="area small"></div>

    <button onclick="sliceTest();">확인</button>

    <script>
        function sliceTest(){
            let area8 = document.getElementById("area8");

            let arr = ["자바", "오라클", 'html', 'css', 'javascript'];

            area8.innerHTML += "arr : " + arr + "<br>";

            // slice(시작 인덱스, 끝 인덱스) => 끝 인덱스는 추출할 요소에 포함되지 않는다.
            area8.innerHTML += "slice 결과 " + arr.slice(2, 4) + "<br>";
            area8.innerHTML += "원본 arr : " + arr + "<br>";
            // 원본 배열에 영향을 끼치지 않음

            // splice(시작 인덱스, 제거 수, 추가할 요소)
            area8.innerHTML += 'splice 결과 : ' + arr.splice(2, 2, "spring") + "<br>";
            area8.innerHTML += "원본 arr : " + arr + "<br>";
        }
    </script>

    <hr>

    <h4>8) join([구분자]) / toString() : 배열에 담긴 값들을 하나의 문자열로 합쳐서 반환해 주는 메서드</h4>

    <button onclick="toStringTest();">확인하기</button>

    <script>
        function toStringTest(){
            let arr = ["나는", "오늘부터", "다이어트를", "시작한다."];

            console.log(arr);
            console.log(arr.toString());
            // 배열 객체를 html 요소에 출력할 경우 내부적으로 .toString() 호출 후 돌아온 결과 출력

            console.log(arr.join());
            // join은 기본적으로 ,를 통해 하나의 문자열로 합친다면
            // join 메서드 호출 시 구분자를 제시하면 해당 구분자를 기준으로 하나의 문자열로 합쳐진다.

            console.log(arr.join(" "));

            console.log("나는,오늘부터,살찐다!!".split(","));

            console.log([1, 2, 3, 4, 5].join("^"));
        }
    </script>

    <hr>

    <h4>9) 배열 반복문</h4>

    <script>
        let arr = ["소금", "삼겹살", "후추", "쌈장"];

        // 향상된 반복문 for of
        for(let food of arr){
            console.log(food);
        }

        // 배열을 통째로 비우는 방법
        arr.length = 0;
        console.log(arr);

        let arr2 = [1, 2, 3, 4, 5];

        console.log(arr2);
        arr2.length = 2;
        console.log(arr2); // 내가 선언한 길이만큼 비워져 있음
    </script>

    <hr>

    <h4>10) 배열을 통한 반복 작업(forEach)</h4>

    <button onclick="foreachTest();">확인</button>

    <script>
        function foreachTest() {
            let a = [1, 2, 3, 4, 5];

            // item(첫 번째 파라미터) : 현재 반복을 진행 중인 요소
            // index(두 번째 파라미터) : 현재 반복을 진행 중인 순서(인덱스)
            // array(세 번째 파라미터) : 반복을 하고 있는 배열
            a.forEach(function(item, index, array){
                console.log(`${item}은 ${array}배열의 ${index}에 위치해 있습니다.`);
            })
            
            // forEach 구문 안에 실행시킬 함수를 추가하기
            a.forEach(testAlert);

            a.forEach(function(text){
                alert(text);
            })
            // alert("출력할 문자")
            // a.forEach(function alert(text){ // text에 들어가는 값은 배열의 반복 중인 요소가 들어감

            //})
            /*
                function alert(text){
                    text 내용을 팝업창에 출력
                }
            */
        }

        function testAlert(text){
            alert(text);
        }
    </script>

    <hr>

    <h4>11) 배열 탐색(find, filter)</h4>

    <p>
        객체로 이루어진 배열에서 내가 원하는 값을 찾을 때 사용
    </p>

    <button onclick="findTest();">확인</button>

    <script>
        function findTest() {
            let a = [
                {id:'qkrrkdud', name:'가영'},
                {id:'qkrrkdud2', name:'가영2'},
                {id:'qkrrkdud3', name:'가영3'},
                {id:'qkrrkdud4', name:'가영4'},
            ]

            let boolean;

            // 내가 원하는 요소를 찾으면 true 값을 반환시킨 후 item 값을 최종적으로 반환 후 반복 종료(찾는 값이 없다면 undefined 반환)
            boolean = a.find(function(item, index, array){
                console.log(item, index, array);
                if(item.id == 'qkrrkdud2'){
                    return true;
                }
            })

            console.log(boolean);

            let filteredArray;

            // 조건을 충족하는 요소가 있으면 해당 요소를 순차적으로 반환함(하나도 없다면 빈 배열 반환)
            filteredArray = a.filter(function(item, index, array){
                // [] --> true 값이 반환 시 배열 안에 현재 반복을 진행 중인 요소가 추가됨
                // 요소.includes("문자열") :  요소에 문자열이 포함되어 있는 경우 true / 포함되지 않은 경우 false
                if(item.id.includes("qkrrkdud")){
                    return true; 
                }
            })

            // 화살표 함수로 축약 시키기
            a.filter(item => item.id.includes("qkrrkdud"));
            a.filter((item) => {
                return item.id.includes("qkrrkdud")
            });
        }
    </script>

    <hr>

    <h4>12) 배열 변형(map)</h4>

    <p>
        현재 배열을 바탕으로 각 요소에 함수를 호출하여 내가 원하는 값으로 변경한 후 결과 값을 반환함
    </p>
        <!-- map, filter, forEach 진짜 많이 사용되는 메서드들 -->

    <button onclick="mapTest();">확인</button>

    <script>
        function mapTest(){
            let result = [1, 2, 3, 4, 5];

            let mappedResult;

            mappedResult = result.map(function(item, index, array){
                return item*index; // return 시킨 값들이 배열 안에 차곡차곡 쌓인 후 반환된다.
            });
            console.log(mappedResult);
        }
    </script>
</body>
</html>